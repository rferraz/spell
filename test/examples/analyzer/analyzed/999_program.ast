((method error#signal (activation (arguments 1) ()) (primitive error#signal))
 (method math#sqrt (activation (arguments 1) ()) (primitive math#sqrt))
 (method math#round (activation (arguments 1) ()) (primitive math#round))
 (method null (activation (arguments 1) ()) (primitive list#null))
 (method head (activation (arguments 1) ()) (primitive list#head))
 (method tail (activation (arguments 1) ()) (primitive list#tail))
 (method invert (activation (arguments 1) ()) (primitive invert))
 (method first (activation (arguments 1) ()) (primitive array#first))
 (method last (activation (arguments 1) ()) (primitive array#last))
 (method length (activation (arguments 1) ()) (primitive array#length))
 (method account#create (activation (arguments 1) ()) 
         (dictionary new ((balance (load value 0)))))
 (method account#deposit (activation (arguments 2) ())
         (dictionary new ((balance (invoke + (dictionary access (load value 0) balance) (load value 1))))))
 (method account#withdraw (activation (arguments 2) (const "Insufficient funds!"))
         (case ((invoke < (dictionary access (load value 0) balance) (load value 1))
                (invoke error#signal (load const 0)))
                (()
                 (dictionary new ((balance (invoke - (dictionary access (load value 0) balance) (load value 1))))))))
 (method main (activation (bindings 1) (const 10) (const 200) (const 30))
         (store value 0 (invoke account#create (load const 0)))
         (invoke account#deposit (load value 0) (load const 0))
         (invoke account#deposit (load value 0) (load const 1))
         (invoke account#withdraw (load value 0) (load const 2)))
 (method fib#recursive (activation (arguments 1) (const 1) (const 2))
         (case ((invoke <= (load value 0) (load const 0))
                (load value 0))
               (()
                (invoke + (invoke fib#recursive (invoke - (load value 0) (load const 0)))
                          (invoke fib#recursive (invoke - (load value 0) (load const 1)))))))
 (method fib#iterative (activation (arguments 1) (bindings 2) (const 5) (const 1) (const 2))
         (store value 1 (invoke math#sqrt (load const 0)))
         (store value 2 (invoke / (invoke + (load const 1) (load value 1)) (load const 2)))
         (invoke math#round (invoke ** (load value 2) (invoke / (load value 0) (load value 1)))))
 (method filter (activation (arguments 2) ())
         (case ((invoke null (load value 1))
                (load value 1))
               ((invoke apply (load value 0) (invoke head (load value 1)))
                (invoke : (invoke head (load value 1)) (invoke filter (load value 0) (invoke tail (load value 1)))))
               (()
                (invoke filter (load value 0) (invoke tail (load value 1))))))
 (method array#partition (activation (arguments 2) ())
         (invoke ! (invoke filter (load value 1) (load value 0))
                   (invoke filter (invoke invert (load value 1)) (load value 0))))
         
 (method __inner__quicksort'__1 (activation (arguments 1) (bindings 2) (const 2))
         (store value 1 (array access (load value 0) (invoke / (invoke length (load value 0)) (load const 0))))
         (store value 2 (invoke array#partition (load value 0) (closure (activation (arguments 1) ()) (invoke < (load value 0) (up 1 1)))))
         (invoke ++ (invoke quicksort (invoke first (load value 2)))
                    (invoke quicksort (invoke last (load value 2)))))
 (method quicksort (activation (arguments 1) (const 1))
         (case ((invoke <= (invoke length (load value 0)) (load const 0))
                (load value 0))
               (()
                (invoke __inner__quicksort'__1 (load value 0))))))